    <!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Lazy Load Meshes</title>

        <!-- Babylon.js -->
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>


        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>

    <script>

var createScene = async function (zones) {
    // This creates a basic Babylon Scene object (non-mesh)
    var scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0, 0, 0);
    // This creates and positions a free camera (non-mesh)
    var camera = new BABYLON.UniversalCamera("camera1", new BABYLON.Vector3(-10, 2.3, -5), scene);
    // This targets the camera to scene origin
    camera.setTarget(BABYLON.Vector3.Zero());
    camera.speed = 100
    camera.maxZ = 100000;
    // This attaches the camera to the canvas
    camera.attachControl(true);

    // // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

    var mat = new BABYLON.StandardMaterial("mat", scene);
    var texture = new BABYLON.Texture("https://storage.googleapis.com/chrisyoung-io/assets/img/building_net_1_b.png", scene);
    mat.diffuseTexture = texture;
    mat.freeze();

      // show axis
  var showAxis = function(size) {
    var makeTextPlane = function(text, color, size) {
    var dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", 50, scene, true);
    dynamicTexture.hasAlpha = true;
    dynamicTexture.drawText(text, 5, 40, "bold 36px Arial", color , "transparent", true);
    var plane = new BABYLON.Mesh.CreatePlane("TextPlane", size, scene, true);
    plane.material = new BABYLON.StandardMaterial("TextPlaneMaterial", scene);
    plane.material.backFaceCulling = false;
    plane.material.specularColor = new BABYLON.Color3(0, 0, 0);
    plane.material.diffuseTexture = dynamicTexture;
    return plane;
     };

    var axisX = BABYLON.Mesh.CreateLines("axisX", [
      new BABYLON.Vector3.Zero(), new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, 0.05 * size, 0),
      new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, -0.05 * size, 0)
      ], scene);
    axisX.color = new BABYLON.Color3(1, 0, 0);
    var xChar = makeTextPlane("X", "red", size / 10);
    xChar.position = new BABYLON.Vector3(0.9 * size, -0.05 * size, 0);
    var axisY = BABYLON.Mesh.CreateLines("axisY", [
        new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3( -0.05 * size, size * 0.95, 0),
        new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3( 0.05 * size, size * 0.95, 0)
        ], scene);
    axisY.color = new BABYLON.Color3(0, 1, 0);
    var yChar = makeTextPlane("Y", "green", size / 10);
    yChar.position = new BABYLON.Vector3(0, 0.9 * size, -0.05 * size);
    var axisZ = BABYLON.Mesh.CreateLines("axisZ", [
        new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3( 0 , -0.05 * size, size * 0.95),
        new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3( 0, 0.05 * size, size * 0.95)
        ], scene);
    axisZ.color = new BABYLON.Color3(0, 0, 1);
    var zChar = makeTextPlane("Z", "blue", size / 10);
    zChar.position = new BABYLON.Vector3(0, 0.05 * size, 0.9 * size);
  };

  showAxis(5);

    const box = BABYLON.MeshBuilder.CreateBox("box",
    {height: 3, width: 1, depth: 1,
    faceUV:[new BABYLON.Vector4(.25, 1, 0, .29), // reverse side
            new BABYLON.Vector4(.0, .29, .25, 1), // side
            new BABYLON.Vector4(.2, .2, .2, .2), // ???
            new BABYLON.Vector4(1, 1, .275, .75),   // A side
            new BABYLON.Vector4(0, 0, .2, .2),  // top
            new BABYLON.Vector4(1, .2, 0, 0)]});
    box.material = mat;
    box.position = new BABYLON.Vector3(0, 0, 0);
    scene.blockMaterialDirtyMechanism = true;

    // const env = scene.createDefaultEnvironment();

    var x_prev;
    var z_prev;

    scene.registerBeforeRender(function(scene) {

        // Find out where we are
        const pos = scene.activeCamera.position.clone();
        // City gird is broken down into squares (zones)
        const zone_size = 6400;
        const mid_point = 6;
        const offset = 34000; // MAGIC NUMBER !!!
        // We want to know which zone (square on the city gird) we are
        // console.log(pos.x, pos.z)
        const x_pos = Math.floor(pos.x / zone_size) + mid_point;
        const z_pos = Math.floor(pos.z / zone_size) + mid_point;

        let x_start, y_start, x_control, y_control, x_end, y_end;

        if ((x_pos != x_prev) || (z_pos != z_prev)) {
            console.log(x_pos, z_pos)
            try {
                // Look up what is nearby that we should now show
                if ((zones[x_pos][z_pos] === null) || (zones[x_pos][z_pos] === undefined)) {
                  console.log('empty zone');
                } else
              {
                zones[x_pos][z_pos].streets.forEach((element) => {
                  switch (element.type) {
                    case "bresenham":
                      console.log("bresenham");
                      y_start = element.geometry.start.y - offset
                      x_start = element.geometry.start.x - offset
                      y_end = element.geometry.end.y - offset
                      x_end = element.geometry.end.x - offset

                      console.log(x_start, y_start, x_end, y_end, x_pos, z_pos);

                      // element.geometry.start.y + offset
                      lines = BABYLON.MeshBuilder.CreateLines("lines", {
                        points: [
                          new BABYLON.Vector3(x_start,
                            0, y_start),
                          new BABYLON.Vector3(x_end,
                            0, y_end)
                        ]
                      }, scene);
                      break;
                    case "bezier":
                      console.log("bezier");
                        y_start = element.geometry.start.y - offset
                        x_start = element.geometry.start.x - offset
                        y_control = element.geometry.control.y - offset
                        x_control = element.geometry.end.x - offset
                        y_end = element.geometry.end.y - offset
                        x_end = element.geometry.end.x - offset
                        quadraticBezierVectors = BABYLON.Curve3.CreateQuadraticBezier(
                                new BABYLON.Vector3(x_start, 0, y_start),
                                new BABYLON.Vector3(x_control, 0, y_control),
                                new BABYLON.Vector3(x_end, 0, y_end),
                                250); // MAGIC
                    default:
                      console.log("unknown type" + element.type);
                  }

                })
              }
                // Check if anything is now out of range and should not be shown
                console.log("unload!")
                // thing.dispose();
            }
            catch(err) {
              console.log(x_pos, z_pos)
              console.log([x_pos][z_pos])
              console.log(err);
            }
            x_prev = x_pos;
            z_prev = z_pos;
        }
    });

    return scene;

};

const canvas = document.getElementById("renderCanvas"); // Get the canvas element
const engine = new BABYLON.Engine(canvas, false, null, false); // Generate the BABYLON 3D engine

fetch('assets/meshes/zones.json')
  .then(response => response.json())
  .then(data => {
    createScene(data).then(function (scene) {

      // Register a render loop to repeatedly render the scene
      engine.runRenderLoop(function () {
        scene.render();
      });
      // Watch for browser/canvas resize events
      window.addEventListener("resize", function () {
        engine.resize();


      });

    }) //Call the createScene function
  });
    </script>

</body>
</html>

    
